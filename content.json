{"meta":{"title":"Reficul","subtitle":null,"description":null,"author":"Reficul","url":"https://reficul.io"},"pages":[],"posts":[{"title":"用Blaze实现Golang泛型","slug":"go-generic-type-with-blaze","date":"2019-02-08T20:45:16.000Z","updated":"2019-02-17T16:05:24.047Z","comments":true,"path":"2019/02/09/go-generic-type-with-blaze/","link":"","permalink":"https://reficul.io/2019/02/09/go-generic-type-with-blaze/","excerpt":"Golang是一门工程语言，语法元素很少很容易掌握。从而，只要不是太扯的人写出来的代码理应相差不大，并能够很快被人理解。泛型在现代编程语言中被广泛使用，这里不谈Go确实泛型是否是一种糟糕的设计，纯粹前段时间在gvisor的代码中看见一种实现泛型的方式比较新奇，因此拿来记录一下。","text":"Golang是一门工程语言，语法元素很少很容易掌握。从而，只要不是太扯的人写出来的代码理应相差不大，并能够很快被人理解。泛型在现代编程语言中被广泛使用，这里不谈Go确实泛型是否是一种糟糕的设计，纯粹前段时间在gvisor的代码中看见一种实现泛型的方式比较新奇，因此拿来记录一下。 老套路由于Go本身并不支持泛型，常见的编程套路有以下几种： 尽可能的重复自己：常见食用方式即使用vim宏、sublime、vscode提供的多行编辑与正则替换功能，来达到Write Once, Paste Anywhere的目的。这也是广大人民最喜闻乐见的黑Go的方式，比如下面这张图： 尽可能的使用空接口和map：为了实践Don’t Repeat Yourself的金玉良言，各路神仙纷纷使用起interface{}配合嵌套map[string]interface{}.完美,要用啥再下断言。毕竟超过两次的就需要抽象了，而空接口是一切抽象最终形态，毕竟只要你想，空接口这种抽象能够装下整个宇宙。 利用工具生成代码：整一个模板扣几个洞，佐上Jinja2、Mustache、Go Template啥的，基于字符串把我要的类型替换进去。啥？你说基于字符串的替换没有语义，不能用编译器检查与法还容易错？拜托，又不是不能用，要啥自行车？。至于自动化嘛，其实go generate还是能用的，至少比没有好对吧。 新亮点gvisor项目里，third_party/gvsync这个包利用了Blaze+一个小工具，实现了一个简单的泛型方案。虽然不可能从语言级别上让出发已久的Go支持泛型，不过这也是一种比较优雅的方案了。这个方案本质上属于上面的套路3，是一种基于模板的泛型方案，但是更精致一些。 依赖于构建工具Balze，在构建的时候按需生成代码。模板只写一份，哪个包用到这个泛型算法，就在那个中声明依赖和目标类型即可。而不是在算法处一次性生成一大堆wrapper，真正做到了泛型想做到的解耦。 类型安全：模板只是一个普通的Go源代码文件，可以被编译器进行语法检查，甚至运行测试。 基于AST，而不是简单的字符串替换。直接操作抽象语法树，把模板源代码文件中的某一个类型替换为目标类型，不但保证序列化后的代码一定合法，而且实现了如果出现同名的元素不会被错误的替换，甚至在新的子作用域中，不会替换自作用域中同名的元素。 细节要实现这个功能，需要一个命令行工具对模板进行渲染，以及构建系统的支持从而实现自动化构建。 渲染工具这个渲染工具是gvisor为了在项目里使用而写的，并非一个专业的渲染模板。但是就功能上而言，应该已经能够胜任Go在泛型渲染上的需求。这个工具的代码位于tools/go_generics，主要功能就在此的3个文件之内，不到500行代码里。处理的流程大致按照以下步骤： 将单个Go源码文件读入内存并利用标准库中自带的Parser解析到AST； 把注释和import信息统计进map，以供生成代码的时候去除不需要的注释和依赖包； 遍历AST，对Global作用域内的节点以及别处的引用按照CMD Flag中的设置进行替换； 去除AST内需要去除的原始类型定义； 依照魔改后的AST，对照过程（2）中map中的信息重新生成新的Go源码。 利用这个工具，能够做到一下事情： 将模板中定义的一个类型按照Go的语义重构成一个新的类型； 将模板中定义的用来占位的类型以及其方法完全删除； 将模板中的类型以及函数添加后缀，并修改此类型的引用（例如类型断言等）； 修改全局定义的常量以及包名。 构建工具集成Blaze类Python的语法提供了极大的自由度，在tools/go_generics/defs.blz中定义了上述命令行工具的wrapper。利用这个封装，任何模块下的BUILD脚本都可以import这个定义文件，从而支持泛型模板的渲染。 _go_template_instance_impl实现了对命令行工具的封装，把命令行的Flag都封装成了一个配置对象。 在BUILD中import上述定义文件，比如third_party/gvsync。在这个包里，generic_atomicptr.go和generic_seqatomic.go便是一个泛型。以后者为例，使用这个泛型的测试的BUILD文件：third_party/gvsync/seqatomictest/BUILD中所定义的：12345678910go_template_instance( name = \"seqatomic_int\", out = \"seqatomic_int.go\", package = \"seqatomic\", suffix = \"Int\", template = \"//third_party/gvsync:generic_seqatomic\", types = &#123; \"Value\": \"int\", &#125;,) 将third_party/gvsync/seqatomic_unsafe.go作为模板，将Value类型换成int类型，并在导出的方法和类型后添加Int后缀。比如原本的func SeqAtomicLoad(sc *gvsync.SeqCount, ptr *Value) Value方法，经过渲染的结果则为func SeqAtomicLoadInt(sc *gvsync.SeqCount, ptr *int) int。 结论Go没有泛型的支持，的确对代码的表现能力进行了极大的限制；而众多泛型的山寨版本也没一个好用的，本文提到的这种方式至少也提供了一种尝试。好处：泛型算法提供者和使用者解耦了，使用源生Go代码作为模板，支持测试和补全等；坏处：使用难度较高，心智负担不必直接支持泛型低，甚至更高。 所以，Go Sucks","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"Balze","slug":"Balze","permalink":"https://reficul.io/tags/Balze/"},{"name":"generic-type","slug":"generic-type","permalink":"https://reficul.io/tags/generic-type/"}]},{"title":"Shadowsocks-go 源码分析","slug":"Shadowsocks_go_source_code_analysis","date":"2016-05-11T17:11:00.000Z","updated":"2019-02-08T20:30:18.211Z","comments":true,"path":"2016/05/12/Shadowsocks_go_source_code_analysis/","link":"","permalink":"https://reficul.io/2016/05/12/Shadowsocks_go_source_code_analysis/","excerpt":"Shodowsocks是一个小有名气的代理工具，主要致力于减小流量特征，从而达到GFW无法对其进行定向的封杀的目的。Shadowsocks有多种语言的实现，本着学习一下原理的心态，看了一下其用Go版本的实现细节。","text":"Shodowsocks是一个小有名气的代理工具，主要致力于减小流量特征，从而达到GFW无法对其进行定向的封杀的目的。Shadowsocks有多种语言的实现，本着学习一下原理的心态，看了一下其用Go版本的实现细节。 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.├── CHANGELOG├── cmd│ ├── shadowsocks-httpget│ │ └── httpget.go│ ├── shadowsocks-local│ │ └── local.go //ss-local主程序│ └── shadowsocks-server│ └── server.go //ss-server主程序├── config.json├── deb //DEB打包配置│ ├── DEBIAN│ │ ├── conffiles│ │ ├── control│ │ ├── postinst│ │ ├── postrm│ │ └── prerm│ └── etc│ ├── init.d│ │ └── shadowsocks│ └── shadowsocks│ └── config.json├── LICENSE├── Makefile //利用Makefile编译安装，安装位置在$GOPATH/bin├── README.md├── sample-config //配置范例│ ├── client-multi-server.json│ └── server-multi-port.json├── script│ ├── build.sh│ ├── createdeb.sh│ ├── curl.sh│ ├── http.go│ ├── README.md│ ├── set-version.sh│ ├── shadowsocks.exe│ ├── test.sh│ └── win32build.bat├── shadowsocks //实现了Shadowsocks包│ ├── config.go //配置解析│ ├── config_test.go│ ├── conn.go //实现了shadowsocks.conn接口，类似net.conn│ ├── encrypt.go //一个封装好的加密库│ ├── encrypt_test.go│ ├── leakybuf.go //一个缓存的实现，避免频繁申请释放内存│ ├── log.go│ ├── mergesort.go //快排(历史遗留问题？Initial commit用到了，现在最新的代码没找到使用)│ ├── pipe.go //对shadowsocks.conn的一个管道封转，用于连接建立后的流量转发│ ├── proxy.go //封装的shadsowsock库，直接与远端ss-server建立连接│ ├── testdata│ │ ├── deprecated-client-multi-server.json│ │ └── noserver.json│ └── util.go //工具集└── TODO 没有实现关于UDP的支持，没有支持Tcp fast open，GoLang的官方网络库貌似还没有支持TFO 核心组件 shadowsocks/conn.go 其具体的通信过程为： 调用RawAddr函数，获取目标服务器地址和端口，并将其封装为以下的格式: 12345+------+-----+-----------------------+------------------+-----------+| ATYP | Len | Destination Address | Destination Port | HMAC-SHA1 |+------+-----+-----------------------+------------------+-----------+| 1 | 1 | Variable | 2 | 10 可选 |+------+-----+-----------------------+------------------+-----------+ ATPY写死了为0x03，其代表了地址类型为域名 Len是地址（域名）的长度 随后的端口是网络序-大端写入的 HMAC校验，当开启一次验证之后会附加在最后，占地10Byte，由IV+key为Key，对前面所有信息的摘要。 DialWithRawAddr函数拿到以上的请求，ss服务器地址以及加密信息之后，向ss服务器发起tcp连接： 首先如果OTA被启用了，会提前生成IV，并立即向ss服务器发送，随后通过shadowsocks.write完成加密Request并发往ss服务器。 12345+-------+---------------+| IV | Encryped Data |+-------+---------------+| Fixed | Variable |+-------+---------------+ 如果OTA为启用，则会直接把请求用Write函数尝试发出，但是发现加密方法未初始化，则初始化IV与Chipher，并将IV附加在加密信息之后一起发出。看Shadowsocks文档显示应该是同时发出的，但是因为tcp是个流，貌似也可以？ 12345+-------+ +---------------+| IV | | Encryped Data |+-------+ +---------------+| Fixed | | Variable |+-------+ +---------------+ 如果一切正常，则返回连接句柄。此时ss-local与ss-server应该已经建立一个TCP连接，数据发送接受已经就绪。而且ss-local已经生成IV与加密方法，ss-server也已经接受到IV并完成了解密方法的初始化。至此，握手阶段结束，剩下的就是pipe通信阶段。 shadowsocks/pipi.go 这个文件中的函数用io包对shadowsocks.conn进行了一个封转，实现了对流量的转发。 转发中，因为已经完成了握手，则数据直接通过pipe进行转发。 在OTA未启用时，即是简单的一个循环，除非转发中出现异常，否则无脑转发。 在OTA启用后，则需要对数据解包，对数据进行校验，只有通过才能被转发，否则pipe将被关闭. 解密之后，包结构如图：第3到12字节为HMAC-SHA1验证信息，是由IV+chunkId为Key，对DATA做的HMAC摘要，本地计算后与包中的相等，则校验通过。 12345+----------+-----------+----------+----| DATA.LEN | HMAC-SHA1 | DATA | ...+----------+-----------+----------+----| 2 | 10 | Variable | ...+----------+-----------+----------+---- cmd/shadowsocks-server/server.go以及cmd/shadowsocks-local/local.go 这个文件为ss-server与ss-local的主程序，完成了代理服务器的作用。 local.go这个程序在本地架设了一个Socks5服务器，接收来自浏览器等应用程序的请求。 依据socks5协议，应用程序会向SOCKS5服务器发送一个握手请求，SOCKS5服务器返回正确信息则握手成功。 随后应用程序向SOCKS5服务器发送代理请求，此时我们的local会解析这个请求，并告诉应用程序，请求已经被接收。随后解析请求，获取目标服务器的地址与端口，用之前shadowsocks.conn中的Dial函数对ss服务器发起请求，等待服务器连接建立，随后两个加密pipe建立，转发来自应用程序到目标服务器的所有流量。 应用程序在收到SOCKS5服务器返回的请求接受回复后，开始向SOCKS5发送数据，数据经过local转发到server再转发到真实的服务器，并原路返回。 server.go这个程序在墙外监听着端口，并时刻准备与local握手，建立pipe，转发数据。GO版本的Server实现了多端口不同密码，即实现了多用户不同密码不同端口。local实现了多服务器，并按照握手失败次数加权，优先连接优质服务器。 一次验证： 每次向io接口中写入数据，或者验证的时候，都会自增一次ChunkID，ChunkID+随机的IV，保证以往的数据包不能被用以重放攻击。","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://reficul.io/categories/Shadowsocks/"}],"tags":[{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://reficul.io/tags/ShadowSocks/"},{"name":"go","slug":"go","permalink":"https://reficul.io/tags/go/"},{"name":"sourcecode","slug":"sourcecode","permalink":"https://reficul.io/tags/sourcecode/"}]},{"title":"Golang中[]Byte与string类转换时内存并不共享","slug":"Golang-byte-string-dont-share-menory","date":"2016-04-19T12:51:00.000Z","updated":"2019-02-08T20:41:12.426Z","comments":true,"path":"2016/04/19/Golang-byte-string-dont-share-menory/","link":"","permalink":"https://reficul.io/2016/04/19/Golang-byte-string-dont-share-menory/","excerpt":"在Golang的基础中我们知道在用append的时候，或者Slice底层数组小于需求容量的时候，Go会自动重新分配内存，随之带来的有一次值拷贝。在数据量小或函数调用不频繁的时候对性能的损失并不明显，但是如果在高频率调用或者数据量大的时候，性能损失不能忽略不计。","text":"在Golang的基础中我们知道在用append的时候，或者Slice底层数组小于需求容量的时候，Go会自动重新分配内存，随之带来的有一次值拷贝。在数据量小或函数调用不频繁的时候对性能的损失并不明显，但是如果在高频率调用或者数据量大的时候，性能损失不能忽略不计。 那么那些情况会触发值拷贝呢？我们来逐一测试： []byte截取： 123456789101112pckage mainimport \"fmt\"func main() &#123; str := []byte(\"this is a fucking string\") str2 := str[0:5] str3 := str2[0:2] fmt.Printf(\"%p\\n\", str) fmt.Printf(\"%p\\n\", str2) fmt.Printf(\"%p\\n\", str3)&#125; 输出： 0xc82000e4e00xc82000e4e00xc82000e4e0 分析： 对[]byte进行了两次切片操作，首地址不变。这也说明了这三个Slice使用了同一个底层数组，并不发生值拷贝。 string与[]byte互相转换: 123456789101112package mainimport \"fmt\"func main() &#123; str := []byte(\"this is a fucking string\") str2 := string(str) str3 := []byte(str2) fmt.Printf(\"%p\\n\", str) fmt.Printf(\"%p\\n\", &amp;str2) fmt.Printf(\"%p\\n\", str3)&#125; 输出： 0xc82000e4e00xc82000a3300xc82000e520 分析： 无论从[]byte到string还是string到[]byte，他们的指针地址均不同。说明在类型转换的时候，发生了值拷贝，而[]byte与string并不共享内存。 查阅资料，发现老外有一篇文章也证明了这个观点： 从Golang Runtime源代码来看，[]byte与string的转换分别调用了以下两个函数： runtime.stringtoslicebyte() runtime.slicebytetostring() 1234567891011121314151617func slicebytetostring(b Slice) (s String) &#123; void *pc; if(raceenabled) &#123; pc = runtime·getcallerpc(&amp;b); runtime·racereadrangepc(b.array, b.len, pc, runtime·slicebytetostring); &#125; s = gostringsize(b.len); runtime·memmove(s.str, b.array, s.len);&#125;func stringtoslicebyte(s String) (b Slice) &#123; b.array = runtime·mallocgc(s.len, 0, FlagNoScan|FlagNoZero); b.len = s.len; b.cap = s.len; runtime·memmove(b.array, s.str, s.len);&#125; 可以看到其中menmove这些内存移动操作。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"技术","slug":"技术","permalink":"https://reficul.io/tags/技术/"}]},{"title":"Go Get Golang.org失败的原因","slug":"Why_Golang_com_fail","date":"2015-11-30T13:36:00.000Z","updated":"2019-02-08T20:35:19.040Z","comments":true,"path":"2015/11/30/Why_Golang_com_fail/","link":"","permalink":"https://reficul.io/2015/11/30/Why_Golang_com_fail/","excerpt":"最近在碰到一个很奇怪的问题，Go get工具在下载golang.org/x/tools下源代码的时候总是失败，但是以前并没有这个问题。Chrome已经使用了Shadowsocks穿墙，但是直接访问这个URL后发现在显示Nothing to see here之后就跳转到了文档页面。本以为是Google Code关闭带来的影响。不过时间过去了一周，并没有改善，奇怪的是老外对此并没有哀嚎遍野。为此有必要看一下go get到底发生了啥了。","text":"最近在碰到一个很奇怪的问题，Go get工具在下载golang.org/x/tools下源代码的时候总是失败，但是以前并没有这个问题。Chrome已经使用了Shadowsocks穿墙，但是直接访问这个URL后发现在显示Nothing to see here之后就跳转到了文档页面。本以为是Google Code关闭带来的影响。不过时间过去了一周，并没有改善，奇怪的是老外对此并没有哀嚎遍野。为此有必要看一下go get到底发生了啥了。 无意中翻到一篇讲述了Go get的过程的文章：https://texlution.com/post/golang-canonical-import-paths/. 文章的意思很简单，大概说的是Go get工具会去所Import的路径下载代码，如果没有，会寻找meta标签中的别名/镜像Repo。 ➜ curl golang.org/x/tools/cmd/rename &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;meta name=&quot;go-import&quot; content=&quot;golang.org/x/tools git https://go.googlesource.com/tools&quot;&gt; &lt;meta name=&quot;go-source&quot; content=&quot;golang.org/x/tools https://github.com/golang/tools/ https://github.com/golang/tools/tree/master{/dir} https://github.com/golang/tools/blob/master{/dir}/{file}#L{line}&quot;&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=https://godoc.org/golang.org/x/tools/cmd/rename&quot;&gt; &lt;/head&gt; &lt;body&gt; Nothing to see here; &lt;a href=&quot;https://godoc.org/golang.org/x/tools/cmd/rename&quot;&gt;move along&lt;/a&gt;. &lt;/body&gt; 而我们之前看到的Nothing to see here只是一个假象，meta标签并不被浏览器显示。傻傻的以为Repo真的被迁移了。 这才发现到了学校之后一直用的SS-local+SwitchOmega上网，并没有配置OpenWrt的透明代理，这才主观上感觉最近Golang.org才挂掉。 总结不是Golang.org代码迁移了，是撞墙了。 解决方案： Proxychains+Shadowsocks的临时使用方案 OpenWrt+Shadowsocks透明代理一次部署，一劳永逸方案 从Github上Get下来，一条条的手动下载。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"GFW","slug":"GFW","permalink":"https://reficul.io/tags/GFW/"}]},{"title":"30天自制操作系统-第二次开启填坑","slug":"Goo-OS_1","date":"2015-07-17T17:34:00.000Z","updated":"2019-02-08T20:40:16.262Z","comments":true,"path":"2015/07/18/Goo-OS_1/","link":"","permalink":"https://reficul.io/2015/07/18/Goo-OS_1/","excerpt":"第二次开始填坑，没有压力真没有动力。老是觉得这样不行那样不行，直到To Do List的堆栈爆了还没动一点点，那还不如开始动手做。上次的进度是认识了实模式，并成功进入了32位模式下，启用了分段的内存管理，打开了保护模式，然后用指针操作了个Demo就草草结束了。","text":"第二次开始填坑，没有压力真没有动力。老是觉得这样不行那样不行，直到To Do List的堆栈爆了还没动一点点，那还不如开始动手做。上次的进度是认识了实模式，并成功进入了32位模式下，启用了分段的内存管理，打开了保护模式，然后用指针操作了个Demo就草草结束了。 这次重新填坑，碰到了很多问题，但是归根到底是经验太缺乏。之前用了GNU一套工具链，自然有的步骤开始脱离书本，想化为己用还是火候不到，碰到了一些问题要花很久才能解决。 书本上还是用的纯汇编来作为C语言的补充，写了一些函数。之前正好看了一些公开课，诶就是网易孟宁老师的Linux内核，看着内联汇编的实现。那这次就用内联汇编吧。敲代码很快，把这些函数作为一个C的库单独解耦出来，命名为lib.c/libc.h编译出了很多错，后来都一一解决了。分别是： Intel风格汇编和A&amp;AT风格汇编的不兼容，之前看的和书本上都是Intel风格的，一时不习惯，编译不能通过。在Makefile中加入编译选项，-masm=intel后解决。 编译提示Push，Pop，MOV等命令与对操作的数据不匹配，折腾后发现我的操作系统是Debian x64位，安装的工具链是64位，再加入编译选项-m32后提示找不到头文件，通过apt-get安装完依赖后解决。 终于编译完毕，make run伴随着一声强烈有力清脆的回车声，大爷的黑屏了。调试了4个小时，此时我的内心是崩溃的。debug过程很蛋疼，因为没法跟踪调试各个参数和查看变量的值，只能注释修改大法，然后发现在io_out8这个函数这里有问题，因为我把这个循环执行一半（把for循环中的end改为个较小数），发现这调色盘是写过的全黑了。辣么不是这个函数有问题就是数据有问题，但是怎么看都不像是数据有问题啊，数组敲错那也不会全黑啊。于是对函数进行编译，反汇编，怀疑是数据类型的问题，因为就传出8位，int等比这个大。折腾了int8_t和int16_t这些，并引入更多的头文件。但是还是不管用，内心崩溃下重新用nasm作为工具，用纯汇编实现了这些函数。结果很高兴的告诉我我内联汇编实现的不错，因为内联汇编是正确的，纯汇编也黑了，以上4小时我再白费工夫。纠结下在bootmain.c中的io_out8()函数中敲入了立即数0xff，0xff，0xff。白屏了，这更说明了函数编写的都是正确的，那么为啥用static unsighed char定义的数组突然不管用了呢？打开Makefile，objcopy -j .text -O binary bootblock.o bootblock.tmp,真想抽自己，我把数据段删了，我把数据段删了，我把数据段删了…………删了……去掉-j .text之后，一切正常了。-","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://reficul.io/categories/操作系统/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"https://reficul.io/tags/30天自制操作系统/"},{"name":"C语言","slug":"C语言","permalink":"https://reficul.io/tags/C语言/"},{"name":"内联汇编","slug":"内联汇编","permalink":"https://reficul.io/tags/内联汇编/"}]},{"title":"30天自制操作系统-第0天，环境搭建","slug":"30-0","date":"2015-02-05T17:25:00.000Z","updated":"2019-02-08T20:40:43.876Z","comments":true,"path":"2015/02/06/30-0/","link":"","permalink":"https://reficul.io/2015/02/06/30-0/","excerpt":"书买了半个月了，也看了前几天的量了。不过一直没动手敲代码，那便不算开始罢。书看得出日文版截稿比较早，内容环境还是基于WinXP（貌似写的WinXP都是时新货的样子XD）光盘附带的工具看得出都是Linux下的一套，Qemu，make，gcc，Makefile。之前架设这个博客的时候就受过惨痛教育（Hexo基于Node.js，上传工具用Git。在windows下用起来，别扭不说，突出一个蛋疼。）于是准备在Debian下部署环境。","text":"书买了半个月了，也看了前几天的量了。不过一直没动手敲代码，那便不算开始罢。书看得出日文版截稿比较早，内容环境还是基于WinXP（貌似写的WinXP都是时新货的样子XD）光盘附带的工具看得出都是Linux下的一套，Qemu，make，gcc，Makefile。之前架设这个博客的时候就受过惨痛教育（Hexo基于Node.js，上传工具用Git。在windows下用起来，别扭不说，突出一个蛋疼。）于是准备在Debian下部署环境。 好的吧，本书看样子截稿是挺久远了，工具下载页面也年久失修啦。打开则纯HTML风迎面飘来。另存到本地，打开后GOOGLE翻译下，有Linux的环境可以直接下载。可是其中内容也是GCC，也是make，何必用他的捏。好吧，这是强迫症，得治疗。自己定义了源代码的目录结构，Makefile准备在以后看书的时候再慢慢写呗。 首先是虚拟机模拟环境：qemu的执行命令和旧版本也有些许不同。旧的命令参考作者网站给出的链接也应该是qemu -m 32 -localtime -STD-VGA -FDA &#39;XXXX.img&#39;而由Apt-get到的版本则是qemu -m 32 -localtime -vga std -fda xxx.img 不过都不是大问题，很快就解决了。但是在链接 C和汇编 Obj文件的时候，出了问题。原书用的是nask，一个修改版的nasm。比起远古版本的nask，我选择了nasm。在这我参考在MAC上搭建环境的这篇文章。所以也用了他的测试代码。编译没有问题，很顺利，可是在链接过程报错了。尝试修改掉汇编源代码中符号前的下划线，并且连接时去掉main前的下划线。再次报错，不过错误减少。看样子和架构有关，但是两个obj文件都已经用参数定义为32位。挠头后一无所获。将两个文件都重新以64位编译，链接成功。但是执行的时候提示段错误。意识到可能ld链接也区分32位和64位。重新查看参数，加入-m elf_i386选项，链接成功，执行成功。 最后环境如下： 由nasm编译nas汇编文件 由GCC编译 C语言文件 由GNU make管理编译过程 由Qemu来做虚拟机，模拟启动。 以上都可以由apt-get获取。 总结 搜索相关结果，旧版本GCC为了兼容老库，会自动添加下划线。而新版本的GCC不再在编译时向符号名中添加下划线。但是可以由选项重新开启这个功能。 ld链接也区分系统架构，mac不需要加选项可能是32位？反正是因为环境不同（在这点上，我傻逼了）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://reficul.io/categories/操作系统/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"https://reficul.io/tags/30天自制操作系统/"},{"name":"GCC","slug":"GCC","permalink":"https://reficul.io/tags/GCC/"},{"name":"汇编","slug":"汇编","permalink":"https://reficul.io/tags/汇编/"},{"name":"C语言","slug":"C语言","permalink":"https://reficul.io/tags/C语言/"}]},{"title":"在Azure搭建ShadowSocks国内跳板，并开启UDP转发。","slug":"Shadowsocks-relay-based-on-Azure","date":"2015-02-04T17:11:00.000Z","updated":"2019-02-08T20:41:43.220Z","comments":true,"path":"2015/02/05/Shadowsocks-relay-based-on-Azure/","link":"","permalink":"https://reficul.io/2015/02/05/Shadowsocks-relay-based-on-Azure/","excerpt":"买BandwagonHost的VPS已经很久了，现在主要也是给朋友用。随着SS名声的变大，搬瓦工这个名字也在圈子里响当当了。用多了加上墙的变高，上海精品网等等的出现，速度越来越不理想。想来国内Azure还在免费，所以拿来搭个跳板机，速度应该会有一些提高。","text":"买BandwagonHost的VPS已经很久了，现在主要也是给朋友用。随着SS名声的变大，搬瓦工这个名字也在圈子里响当当了。用多了加上墙的变高，上海精品网等等的出现，速度越来越不理想。想来国内Azure还在免费，所以拿来搭个跳板机，速度应该会有一些提高。 找到SS的WIKI，搭建一个转发只需要两行Iptables规则，但是根据作者说性能不如Haproxy。由于不需要负载平衡，所以直接照抄方案二的代码就完成了转发服务器的搭建。随之问题来了，UDP转发功能废了。无奈中，搜索得知Haproxy无法转发UDP包。不能转发UDP则不能借助SS-tunnel转发DNS来解决DNS投毒，更不能让走代理的流量获取最快的节点。这显然不能接受。然而正好咱不需要负载平衡，而且用户一只手掰得过来，想来内核级别的iptables性能应该不会差到哪去，并且这种无差别的转发一定是可以支持SS的UDP转发功能的。于是打定主意使用这个方案。半路出家的我对复杂的iptables设置很是头疼，扒了文章了解后，大概得知我们的需求是由SNAT和DNAT合作完成的。简而言之就是我们的客户机上将服务器设置为我们的跳板机，则数据包发送到跳板机上，然后修改源IP和目标IP地址，重新转发给后面真实的SS服务器上，以此完成整个过程。那么依样画葫芦，摘取一下： iptables -t nat -A PREROUTING -p tcp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A POSTROUTING -p tcp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure_IP 以上只转发TCP包，应该能够实现原本基础的功能了，可是经测试无效。检查了Azure网页中的端口映射,检查了iptables是否打开了转发,FORWARD表默认ACCEPT后都没有排除故障，只好用TCPDUMP抓取数据包。抓包后发现，在Azure的机器上，iptables出色的完成了预计的任务（如图）。可是在SS服务器上，则是一个包都没进得来。挠头之余，很是无奈啊。后来发现，Azure在外层有一层NAT，所给虚拟机的IP虽然是公网IP，但是不是绑定在虚拟机网卡上的IP。Azure的防火墙在收到数据包后进行一次NAT，转发给内部虚拟机。出去的数据包也经过一次NAT，之后才进行发送。虽然在出咱虚拟机网卡的包的目标地址被正确的修改，指向了SS-vps，但是源地址是该虚拟机的外网IP（Azure叫他：公用虚拟 IP (VIP)地址），这个包在经国Azure的外围防火墙的时候被丢弃，因为认为这个包的源IP不是内部的服务器的。修改规则后，测试成功。并且SS-tunnel正常。修改后代码如下： iptables -t nat -A PREROUTING -p tcp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A PREROUTING -p udp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A POSTROUTING -p tcp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure内部 IP 地址 iptables -t nat -A POSTROUTING -p udp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure内部 IP 地址 这个事情真的是会的不难，难的不会，加上有个暗坑（Azure的防火墙），让本来不复杂的事情变得困难了一些。不过好处是，在给了我动力和机会实践学习了Iptables的一些概念和命令。对表，链，规则有了基本的认识学习。收益颇多，也做个笔记。 December 7 2015 Updated:腾讯云测试可用","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://reficul.io/categories/Shadowsocks/"}],"tags":[{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://reficul.io/tags/ShadowSocks/"},{"name":"iptables","slug":"iptables","permalink":"https://reficul.io/tags/iptables/"},{"name":"Azure","slug":"Azure","permalink":"https://reficul.io/tags/Azure/"},{"name":"NAT","slug":"NAT","permalink":"https://reficul.io/tags/NAT/"}]},{"title":"Nexus5在Android下开启电信3G心得","slug":"Nexus5 cdma","date":"2014-12-11T02:20:00.000Z","updated":"2019-02-08T20:37:34.284Z","comments":true,"path":"2014/12/11/Nexus5 cdma/","link":"","permalink":"https://reficul.io/2014/12/11/Nexus5 cdma/","excerpt":"流水账记录一下Nexus 5太子在破解使用电信卡的时候遇到的坑。","text":"流水账记录一下Nexus 5太子在破解使用电信卡的时候遇到的坑。 #需要 一个开启Diag的内核 DFS程序 ADB环境 需要Root以使用Nexus5 Field Test Mode程序 #准备 内核部分，我使用了SykopomposStockLollipopKernel.zip这个内核，原帖源于XDA，我没找到。已经开启了Root，Diag。 ROOT部分使用了CF-root的自动root。 Nexus5 Field Test Mode程序部分直接在Google play上下载的，最新版本已经支持了Android 5.0。破解过程遵循《NEXUS 5中文完美电信3G 2.0版》，没啥再加工的和自我创造，我要说的是几点心得。 #心得 在5.0下面也可破解电信，应该无需刷回4.4.2 PRL可以通过短信更新，发短信内容“PRL到”10659165，将受到6条短信，并且提示更新成功。当然前提是能发短信了才能用这个方法更新PRL。 老是显示禁用漫游提示符是因为SID没写，找到NAM选项卡HOME下的SID，写入自己所在归属的的SID，可以搜索下，能找到的。写入立即可以修复禁用漫游提示符的问题，但是如此修改后虽然提示搜到了电信信号但是还是不能打电话发短信，那说明变回了NV-only，需要再改这个。这个变回原理未知，无规律变回。但是SID和这项一起修改貌似可以减少变回的概率。别的分析在《NEXUS 5中文完美电信3G 2.0版》也有说明，可参考。 APN默认是荷兰的一家运营商，同样可以通过修改APN来解决上网问题，不需换卡。我的卡是换Nexus5才换的小卡，所以要换也没有别的卡可以换了，实测这个不影响根本问题，是同样可以使用电信的。 修改APN方面，可以使用海卓。但是在4.0以后得系统中，海卓不再拥有权限修改APN。有个变通的方法是将其变成系统程序。利用钛备份高级版功能，转化为系统APP，然后将/system/app下的海卓apk剪切到system/priv-app下，即可恢复权限，自动修改APN。 PS：变成荷兰之后，因祸得福一件事情。虽然微信等APP自动填写的电话会变成+31要修改，多点击两次略麻烦，但是，Google服务也会把你当作荷兰用户。所以无需root，无需安装local report enabler。修改语言清空Google搜索的数据，即可食用各项谷歌服务，Google now，fit点击就送@。@ 刷完之后没有3G，但是可以打电话，发短信。不能彩信，上网。设置了APN均无效。信号的确是CDMA-EVOD Rev.a 但是信号不咋地，很容易掉到1格。 这个问题消耗了我大约6个小时时间。网络上大多评论换卡的问题，或者是字库被修过等硬件问题。诶，险些让人失去信心啊。其实貌似关键在于DATA选项卡下面的HDR AN和HDR AN LONG上，经过一晚上仅仅修改上面的PPP和PAP失败之后，第二天早上将HDR AN和HDR AN LONG清空之后再写入，问题莫名其妙的好了。 PS：在不停重试写DATA的时候，PWD密码和PPP，PAP改写的还是要写的，读不出来是正常的。 在一切OK之后，3G信号变成了满格，一切正常，彩信也正常。 从4.4.X升级到5.0无需重新破解，无需备份还原等操作，只需要下载Factory image解压后和ADB合体，或者安装ADB之后cd到解压的文件夹，把flash-all.bat/flash-all.sh中的fastboot后面的-w参数删除，直接线刷即可升级到最新的系统。","categories":[{"name":"日志","slug":"日志","permalink":"https://reficul.io/categories/日志/"}],"tags":[{"name":"电信","slug":"电信","permalink":"https://reficul.io/tags/电信/"},{"name":"Android 5.0","slug":"Android-5-0","permalink":"https://reficul.io/tags/Android-5-0/"}]}]}